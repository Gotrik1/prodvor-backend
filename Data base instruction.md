# Руководство по отладке подключения к удаленной БД для Flask-приложения

Этот документ описывает проверенную последовательность действий для диагностики и решения проблем с подключением Flask-приложения к удаленной базе данных PostgreSQL, особенно в нетипичных сетевых условиях (например, Docker-контейнер на Windows-машине и облачный сервер).

## Шаг 1: Диагностика и обеспечение сетевой доступности

**Проблема:** Ваше облачное приложение (сервер) не может установить сетевое соединение с вашей базой данных. `ping`, `telnet` или попытки подключения из кода завершаются по таймауту или с ошибкой "Host not found".

**Решение:** Вместо того чтобы "пробрасывать" порты и настраивать файрволы, что сложно и небезопасно, мы создаем частную виртуальную сеть (VPN) с помощью **Tailscale**.

### Действия:

1.  **Установите Tailscale на обе машины:**
    *   На машине, где работает база данных (ваш локальный ПК).
    *   На сервере, где работает Flask-приложение (облачный инстанс).

2.  **Авторизуйтесь в Tailscale под одним аккаунтом** на обеих машинах. Они автоматически найдут друг друга.

3.  **Найдите IP-адрес машины с БД:** В административной консоли Tailscale найдите вашу машину с Docker и скопируйте ее IP-адрес (обычно вида `100.X.X.X`).

4.  **Проверьте базовое соединение:** На сервере с приложением выполните команду:
    ```bash
    ping <IP-адрес_Tailscale_машины_с_БД>
    ```
    Если пинги проходят — сетевой туннель работает.

5.  **Настройте SOCKS5-прокси для трафика приложения:** Чтобы все запросы от вашего Python-кода (включая запросы к БД) шли через Tailscale, нужно запустить его демон (`tailscaled`) и обернуть запуск приложения в переменную окружения `ALL_PROXY`.

    **Файл `start_server_with_tailscale.sh`:**
    ```bash
    #!/bin/bash

    # 1. Запускаем демон Tailscale в фоновом режиме
    /home/user/.local/bin/tailscaled --tun=userspace-networking --socks5-server=localhost:1080 --statedir=/home/user/.tailscale/stated --socket=/home/user/.tailscale/tailscaled.sock & 

    # 2. Ждем, пока он запустится
    sleep 5 

    # 3. Поднимаем сетевой интерфейс Tailscale
    /home/user/.local/bin/tailscale --socket=/home/user/.tailscale/tailscaled.sock up --accept-routes --accept-dns=false

    # 4. Запускаем наш основной скрипт сервера
    ./devserver.sh
    ```

## Шаг 2: Обеспечение непрерывной работы сервера

**Проблема:** Скрипт `./start_server_with_tailscale.sh` отрабатывает без ошибок, но тут же завершается. Сервер не работает, логов нет.

**Решение:** Главный скрипт (`devserver.sh`) не должен завершаться. Flask-сервер должен быть последней командой и работать в **основном (foreground) режиме**, а не в фоновом. Это удерживает всю цепочку скриптов от преждевременного завершения.

### Действия:

1.  **Найдите команду запуска Flask-сервера.**

2.  **Убедитесь, что в конце команды нет амперсанда (`&`).**

    **Файл `devserver.sh` (Пример правильной конфигурации):**
    ```bash
    #!/bin/bash
    # ... (экспорт переменных окружения) ...

    source .venv/bin/activate
    export FLASK_APP=main.py

    # ПРАВИЛЬНО: Сервер работает в основном режиме, его логи идут в консоль.
    # Переменная ALL_PROXY направляет весь трафик через прокси Tailscale.
    ALL_PROXY=socks5://localhost:1080/ python3 -m flask run --host=0.0.0.0 --port=8080
    ```

## Шаг 3: Анализ ошибок приложения (Traceback)

**Проблема:** Сеть настроена, сервер запускается и не падает, но на запросы (`curl`) отвечает ошибкой `500 Internal Server Error`.

**Решение:** Ошибка `500` — это ошибка **внутри кода** вашего приложения. Ее полный текст (traceback) выводится в той же консоли, где вы запустили сервер.

### Действия:

1.  **Выполните `curl`**, чтобы спровоцировать ошибку.

2.  **Найдите в консоли сервера** блок текста, начинающийся с `Traceback (most recent call last):`.

3.  **Внимательно прочитайте последнюю строку ошибки.** Она точно указывает на причину.

    **Наш случай:**
    ```
    TypeError: 'str' object cannot be interpreted as an integer
    ```
    **Анализ:** Ошибка типов. Где-то в настройках таймаута ожидается число, а передается строка. Это произошло из-за параметра `?timeout=15` в `DATABASE_URL`, который некорректно обрабатывался драйвером `pg8000` при работе через SOCKS-прокси.

4.  **Исправьте конфигурацию:** Мы просто убрали этот параметр из `DATABASE_URL` в файле `.env`.

    **.env (Правильный вариант):**
    ```
    DATABASE_URL=postgresql+psycopg2://prodvor:prodvor@100.83.57.49:5432/prodvor
    ```

5.  **Перезапустите сервер** (`CTRL+C` и заново `./start_server_with_tailscale.sh`), чтобы применились новые настройки.

---

## Бонусный раздел: Как увидеть все SQL-запросы в логах PostgreSQL

**Вопрос:** Почему после успешного `curl`-запроса логи моей базы данных в Docker (`docker compose logs -f db`) остаются пустыми?

**Ответ:** Это нормальное поведение. По умолчанию PostgreSQL **не логгирует** успешные и быстрые `SELECT`-запросы для экономии ресурсов и производительности. Логгируются только ошибки, медленные запросы и события подключения/отключения.

**Решение (для отладки):** Вы можете временно включить полное логирование.

1.  **Включить логирование всех запросов:**
    ```bash
    docker exec -it db psql -U postgres -d prodvor -c "ALTER SYSTEM SET log_statement = 'all';"
    ```

2.  **Применить новую конфигурацию (без перезапуска БД):**
    ```bash
    docker exec -it db psql -U postgres -d prodvor -c "SELECT pg_reload_conf();"
    ```

Теперь, после выполнения `curl`-запроса к вашему API, вы увидите соответствующий `SELECT`-запрос в логах Docker.

**ВАЖНО:** Не забудьте выключить эту настройку после отладки, так как она влияет на производительность.

```bash
docker exec -it db psql -U postgres -d prodvor -c "ALTER SYSTEM SET log_statement = 'none';"
docker exec -it db psql -U postgres -d prodvor -c "SELECT pg_reload_conf();"
```
