# План миграции: APIFlask → FastAPI

Этот документ описывает полный процесс миграции бэкенд-приложения с APIFlask на FastAPI. План охватывает все этапы: от анализа текущего состояния до финальной очистки проекта от старых зависимостей.

## 1. Отчёт по анализу и инвентаризации

### 1.1. Инвентаризация стека, зависимостей и точек входа

| Компонент | Описание и расположение |
| :--- | :--- |
| **Создание приложения** | Фабрика `create_app()` в `app/__init__.py`. Создаётся экземпляр `apiflask.APIFlask`. |
| **Зависимости Flask** | `APIFlask`, `Flask-SQLAlchemy`, `Flask-Migrate`, `Flask-Bcrypt`, `Flask-JWT-Extended`, `Flask-Cors`. |
| **Схема БД и ORM** | Модели в `app/models.py`. Подключение через `Flask-SQLAlchemy`. Миграции управляются `Flask-Migrate` (Alembic), запускаются скриптом `./run_migrations.sh`. |
| **Аутентификация/Авторизация** | JWT-токены через `Flask-JWT-Extended`. Эндпоинты `/login`, `/register`, `/refresh`, `/logout` в `app/routes/auth.py`. Роли (`player`, `referee`, `coach`) задаются при регистрации. Загрузчик пользователя `user_lookup_callback` в `app/__init__.py`. |
| **Интеграции** | **S3**: Кастомный сервис `S3Service` в `app/s3_service.py`, инициализируется в `create_app`. Конфигурация из переменных окружения. *Допущение: другие интеграции (e-mail, очереди) не обнаружены.* |
| **OpenAPI/Swagger** | Генерируется `APIFlask`. Кастомизация (`servers`, `security_schemes`) происходит в `app/__init__.py`. Спецификация для `requestBody` определяется в docstrings роутов. |
| **Скрипты и точки входа** | **Dev**: `./devserver.sh` (запускает `flask run`). <br/> **Prod (Docker)**: `entrypoint.sh` (вероятно, запускает Gunicorn), `docker-compose.yml`. <br/> **Миграции**: `./run_migrations.sh` (выполняет `flask db upgrade`). |
| **Прочее** | **CORS**: `Flask-Cors`, настроен на `resources={r"/api/v1/*": {"origins": "*"}}`. <br/> *Допущение: Rate limiting, кеширование и фоновые задачи на уровне фреймворка не реализованы.* |

### 1.2. Сводка по контрактам API

*Допущение: ниже приведён анализ ключевых эндпоинтов. Полный список требует анализа всех файлов в `app/routes/`.*

| Blueprint | Маршрут | Метод | Авторизация | Тело запроса (формат) | Успешный ответ (код, формат) | Ошибки (коды) |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| `auth_bp` | `/api/v1/auth/register` | POST | Нет | JSON (`email`, `nickname`, `password`, `role`, etc.) | `201`, JSON (данные пользователя) | `409` |
| `auth_bp` | `/api/v1/auth/login` | POST | Нет | JSON (`email`, `password`) | `200`, JSON (`access_token`, `refresh_token`) | `401` |
| `auth_bp` | `/api/v1/auth/refresh` | POST | Refresh JWT | Нет | `200`, JSON (`accessToken`) | `401` |
| `auth_bp` | `/api/v1/auth/logout` | POST | Refresh JWT | Нет | `200`, JSON (`message`) | `401`, `404` |
| `users_bp` | `/api/v1/users/{userId}` | GET | Access JWT | Нет | `200`, JSON (данные пользователя) | `404` |
| `uploads_bp` | `/api/v1/uploads/avatar` | POST | Access JWT | `multipart/form-data` | `200`, JSON (`avatarUrl`) | `400` |
| *Прочие* | `/api/v1/sports`, `/api/v1/playgrounds` | GET | Опционально | query-параметры (фильтрация/пагинация) | `200`, JSON (список объектов) | - |

**Формат ошибок:** В основном используется `abort(code, description)`, что генерирует JSON вида `{"message": "...", "code": ...}`. JWT-ошибки имеют формат `{"error": "...", "detail": "..."}`.

### 1.3. Технические долги и риски

| Категория | Риск/долг | Влияние на миграцию |
| :--- | :--- | :--- |
| **Зависимости** | Жёсткая связка с экосистемой Flask (`Flask-SQLAlchemy`, `Flask-Migrate`, `Flask-JWT-Extended`). | Основная работа — замена этих библиотек на их FastAPI-аналоги или стандартные библиотеки (`SQLAlchemy`, `Alembic`). |
| **Форматы ошибок** | Неконсистентность форматов ошибок (стандартные `abort` vs `flask-jwt-extended`). | Необходимо создать middleware в FastAPI для приведения всех ошибок (`HTTPException`, `RequestValidationError`) к единому формату, который ожидает фронтенд. |
| **Конфигурация** | CORS разрешает все источники (`*`). | Высокий риск для безопасности. При миграции на `CORSMiddleware` в FastAPI необходимо сразу заложить строгую конфигурацию для `dev`/`prod` окружений. |
| **Развёртывание** | Завязка на dev-сервер (`flask run`) в скрипте `devserver.sh`. | `entrypoint.sh` и `Dockerfile` потребуют обновления для запуска через ASGI-сервер (`gunicorn` с воркерами `uvicorn`). |
| **Валидация** | `APIFlask` возвращает ошибки валидации с кодом `400` или `422`. Фронтенд может быть завязан на этот формат. | FastAPI по умолчанию использует `422` для ошибок валидации Pydantic. Необходимо убедиться, что формат тела ошибки совпадает с ожидаемым или написать обработчик исключения `RequestValidationError`. |

---

## 2. Выбранный стек и стратегия миграции

### 2.1. Целевой технологический стек

| Компонент | Технология | Обоснование |
| :--- | :--- | :--- |
| **Фреймворк** | **FastAPI** | Высокая производительность (ASGI), встроенная валидация данных (Pydantic), автоматическая генерация OpenAPI, система зависимостей. |
| **Веб-сервер** | **Gunicorn + Uvicorn** | Промышленный стандарт для запуска ASGI-приложений в production. `Gunicorn` как менеджер процессов, `Uvicorn` как ASGI-воркер. |
| **БД и ORM** | **SQLAlchemy 2.0 (sync)** | Мощная ORM, нативная поддержка которой есть в FastAPI. Начнём с синхронного кода для упрощения миграции. |
| **Миграции** | **Alembic** (напрямую) | Стандарт де-факто для миграций с SQLAlchemy. Отвязка от `Flask-Migrate` упростит зависимости. |
| **Валидация/Схемы**| **Pydantic v2** | Интеграция с FastAPI «из коробки», мощные возможности для валидации и типизации, повышение надёжности кода. |
| **Настройки** | **Pydantic-Settings** | Типобезопасная конфигурация из `.env` файлов и переменных окружения, идеально сочетается с Pydantic. |
| **Безопасность** | **OAuth2PasswordBearer + PyJWT** | Стандартный, прозрачный и гибкий способ реализации JWT-аутентификации без «магии» сторонних библиотек. |
| **CORS** | **FastAPI CORSMiddleware** | Встроенное, простое и эффективное решение. |
| **Rate Limiting** | **fastapi-limiter + Redis** | Популярное и надёжное решение для защиты от брутфорса и злоупотреблений API. |
| **Логирование** | **Structlog** (или **Loguru**) | Структурированные логи в JSON-формате упрощают парсинг, поиск и анализ в системах вроде ELK/Splunk. |
| **Работа с S3** | **Boto3** | Официальный SDK от Amazon, стандарт для работы с S3. |

### 2.2. Стратегия миграции: Strangler Fig Pattern

1.  **Параллельное развёртывание**: Новое приложение на FastAPI разворачивается рядом с существующим приложением на Flask.
2.  **Проксирующий слой (API Gateway)**: Перед обоими приложениями ставится прокси-сервер (Nginx или Kong), который выступает единой точкой входа.
3.  **Поэтапное перенаправление**:
    *   Изначально прокси направляет 100% трафика на старое Flask-приложение.
    *   По мере готовности роутов в FastAPI (например, `/api/v1/auth/*`), мы настраиваем прокси так, чтобы он направлял запросы по этим путям на новое FastAPI-приложение.
    *   Остальной трафик продолжает идти на Flask.
4.  **Итеративное замещение**: Постепенно, роут за роутом, «перехватываем» трафик, пока 100% запросов не будут обрабатываться новым приложением.
5.  **Вывод из эксплуатации**: Когда все эндпоинты перенесены и протестированы, старое Flask-приложение выключается и удаляется.

---

## 3. Архитектурная схема целевого приложения

### 3.1. Структура директорий

```
/
├── app/
│   ├── core/
│   │   ├── __init__.py
│   │   ├── config.py         # Настройки (Pydantic-Settings)
│   │   ├── database.py       # SQLAlchemy Engine, SessionLocal
│   │   ├── security.py       # JWT, хэширование паролей, OAuth2
│   │   ├── logging.py        # Настройка Structlog/Loguru
│   │   └── exceptions.py     # Глобальные обработчики исключений
│   │
│   ├── models/
│   │   ├── __init__.py
│   │   └── user.py           # ORM-модели SQLAlchemy
│   │
│   ├── schemas/
│   │   ├── __init__.py
│   │   └── auth.py           # Pydantic-схемы для запросов/ответов
│   │
│   ├── services/
│   │   ├── __init__.py
│   │   └── s3_service.py     # Бизнес-логика, работа с S3
│   │
│   ├── routers/
│   │   ├── __init__.py
│   │   └── auth.py           # APIRouter для домена 'auth'
│   │
│   └── middleware/
│       ├── __init__.py
│       └── error_compat.py   # Middleware для совместимости форматов ошибок
│
├── migrations/               # Alembic миграции
│
├── tests/
│
├── .env
├── main.py                   # Точка входа в FastAPI приложение
├── alembic.ini               # Конфигурация Alembic
└── requirements.txt
```

### 3.2. Ответственность слоёв

*   **`main.py`**: Создание экземпляра `FastAPI`, подключение CORS, middleware, роутеров.
*   **`app/routers/`**: Обработка HTTP-запросов, валидация данных, вызов сервисов.
*   **`app/schemas/`**: Определение структуры данных (Pydantic) для запросов/ответов.
*   **`app/services/`**: Реализация всей бизнес-логики.
*   **`app/models/`**: Определение структуры таблиц БД (SQLAlchemy).
*   **`app/core/`**: Сквозная функциональность (конфигурация, БД, безопасность, логирование).

---

## 4. Дорожная карта миграции

| Фаза | Задачи | Риски и как их минимизировать | Definition of Done (DoD) |
| :--- | :--- | :--- | :--- |
| **A. Подготовка** | 1. Создать новую структуру папок. <br>2. Настроить `pydantic-settings`. <br>3. Настроить `SQLAlchemy 2.0` (синхронно). <br>4. Инициализировать FastAPI с CORS и роутом `/healthz`. <br>5. Настроить Alembic. | Несовместимость конфигурации. **Минимизация**: Тщательно перенести все переменные из `.env`. | FastAPI приложение запускается. Роут `/healthz` отвечает `200 OK`. Alembic готов к созданию миграций. |
| **B. Аутентификация** | 1. Реализовать генерацию/проверку JWT. <br>2. Создать зависимость `get_current_user`. <br>3. Создать middleware для совместимости ошибок. <br>4. Настроить Redis для будущего blacklist'а. | Несовпадение в логике JWT. **Минимизация**: Внимательно скопировать параметры и логику из `Flask-JWT-Extended`. | JWT-токены, сгенерированные FastAPI, валидны. Защищённые эндпоинты корректно возвращают ошибки в старом формате. |
| **C. Маршруты 1-й очереди** | 1. Перенести роуты `auth` и `users`. <br>2. Интегрировать `fastapi-limiter` на `/login`. <br>3. Внедрить `structlog`. | Ошибки в бизнес-логике. **Минимизация**: Переносить логику "как есть", меняя только обвязку фреймворка. | Роуты `/api/v1/auth/*` и `/api/v1/users/*` полностью функциональны в FastAPI. Логи пишутся в JSON. |
| **D. Проксирование и тесты** | 1. Настроить Nginx/Kong для проксирования роутов. <br>2. Написать контрактные тесты. <br>3. Провести минимальное нагрузочное тестирование. | Сложности с конфигурацией прокси. **Минимизация**: Начать с одного роута, убедиться в работоспособности. | Трафик на перенесённые роуты успешно обрабатывается FastAPI. Контрактные тесты проходят. |
| **E. Полный перенос** | 1. Итеративно переносить оставшиеся blueprints. <br>2. Для каждого домена обновлять конфигурацию прокси. | "Тихие" баги. **Минимизация**: Постоянно прогонять сценарные и контрактные тесты. | 100% трафика API обрабатывается FastAPI. Старое Flask-приложение больше не получает запросов. |
| **F. Оптимизация (опц.)** | 1. Перевести "тяжёлые" операции на `async` клиенты (`aioboto3`, `httpx`). <br>2. Настроить сбор метрик Prometheus. | Проблемы с `async`. **Минимизация**: Использовать `async` только там, где это действительно необходимо. | Ключевые I/O-операции выполняются асинхронно. Включен экспорт метрик. |
| **G. Финальная очистка** | 1. Удалить `Flask` и `Flask-*` зависимости. <br>2. Удалить старые файлы. <br>3. Обновить `Dockerfile` и `entrypoint.sh`. <br>4. Обновить `README.md`. | Случайное удаление нужных файлов. **Минимизация**: Провести ревизию кода на наличие импортов `flask`. | Проект полностью очищен от Flask. `pip freeze` не показывает Flask-зависимостей. Все тесты проходят. |

---

## 5. Политика совместимости и рисков

-   **[ ] Форматы ошибок**: Все ошибки `4xx`/`5xx` должны возвращать JSON в формате `{ "message": "string", "code": "optional_string" }`.
-   **[ ] Дата и время**: Все поля с датой/временем должны быть строками в формате `ISO-8601` с `UTC` (e.g., `2023-10-27T10:00:00Z`).
-   **[ ] JSON Нейминг**: Сохранить существующую конвенцию именования полей (`camelCase`), используя `alias_generator` или `Field(alias=...)` в Pydantic.
-   **[ ] CORS**: Создать явные списки `ALLOW_ORIGINS` для `dev`/`prod`. Никаких `*` в production.
-   **[ ] Сессии БД**: Строго придерживаться паттерна "одна сессия на один запрос" (`Depends(get_db)`).
-   **[ ] OpenAPI**: `operationId` для каждого эндпоинта в FastAPI должен совпадать со старым API.

---

## 6. План тестирования

| Тип теста | Цель | Инструменты/Методы | Критерии успеха |
| :--- | :--- | :--- | :--- |
| **Контрактные** | Гарантировать 100% совпадение ответов нового и старого API. | Pytest, `requests`. Запись "золотых" ответов (golden files) и сравнение с ними. | Ответы FastAPI (тело, заголовки, код) побайтово совпадают с эталонными ответами Flask. |
| **Сценарные** | Проверка бизнес-логики. | Pytest, `httpx.AsyncClient`. | Все шаги сценария (регистрация → логин → ... → логаут) выполняются успешно. |
| **Нагрузочные** | Определение производительности. | `locust`, `k6`. | p95/p99 времени ответа в пределах SLO. Уровень ошибок < 0.1%. |
| **Проверка CORS** | Проверить CORS-политики. | `curl` с заголовком `Origin`. | Запросы с разрешённых доменов проходят, с неразрешённых — блокируются. |
| **Проверка лимитов** | Проверить Rate Limiting. | Скрипт, >N запросов/сек. | (N+1)-й запрос получает ошибку `429 Too Many Requests`. |
| **Health Checks** | Проверка `healthz` и `readyz`. | `curl` или проверки оркестратора. | `/healthz` всегда `200 OK`. `/readyz` отвечает `200 OK` только если есть подключение к БД/Redis. |

---

## 7. План финальной очистки от Flask

| Действие | Что сделать | Критерий выполнения |
| :--- | :--- | :--- |
| **1. Удалить зависимости** | В `requirements.txt` удалить все `Flask*` и `APIFlask`. Выполнить `pip install -r requirements.txt` и `pip uninstall ...`. | `pip freeze | grep -i flask` не выводит ничего. |
| **2. Удалить код Flask** | Удалить `app/routes/`, `app/__init__.py`, `devserver.sh`, `.flaskenv`. | Поиск по проекту не находит `import flask` или `import apiflask`. |
| **3. Обновить Docker** | **`Dockerfile`**: `CMD` на запуск `gunicorn`. <br>**`entrypoint.sh`**: `flask db upgrade` → `alembic upgrade head`. | Приложение собирается и запускается через `docker-compose up`. |
| **4. Очистить прокси** | В конфигурации Nginx/Kong удалить все упоминания старого Flask-приложения. | Конфигурация прокси содержит только один бэкенд-сервис. |
| **5. Обновить CI/CD** | Обновить шаги линтинга, тестов, сборки и деплоя под новый стек. | CI/CD пайплайн успешно проходит для нового приложения. |
| **6. Финальная верификация** | Полностью прогнать `План тестирования` (Документ 6) на чистом проекте. | Все тесты пройдены. Документация OpenAPI (`/docs`) корректна. |
| **7. Обновить документацию** | Обновить `README.md` (локальный запуск, переменные, структура). | Документация актуальна и позволяет быстро развернуть проект. |

